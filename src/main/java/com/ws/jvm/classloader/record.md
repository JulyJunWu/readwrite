
不规范笔记



  类型的加载->连接->初始化 都是在程序运行期间完成的.
  连接阶段 : 验证 准备 解析

  符号引用转为直接引用

  JAVA虚拟机结束生命周期:
    1.程序正常结束;
    2.调用System.exit()
    3.程序抛出异常
    4.操作系统发生故障,如:结束进程(kill)

  1.加载:
      查找并加载二进制字节码数据; 就是将class文件加载进JVM,将其放在运行时数据区的方法区,并在堆中创建一个class对象,用来封装类在的方法区的数据结构
      注意: JVM规范并未规定class对象放在哪里

      查找加载的范围很广, 并不局限于从本地加载文件, 如从数据库加载二进制字节流数据直接在内存中生成类,又或者通过URL访问加载,文件载体常见有.zip .jar等等


  2.连接:又分为三个阶段
      2.1 验证  主要是验证字节码的一些规范,是否安全,比如验证魔数,主版本和次版本 ; 是否符合,比如final类是否有子类等等
      2.2 准备  为静态变量分配内存,并将其初始化默认值 , 如 int默认0 , String(引用类)默认null,boolean默认false ; 准备阶段是赋予默认值,并非实际分配的值,实际的值在初始化阶段赋予真正的值;
             注意: 如果是final修饰的静态常量,那么是直接赋予真正的值, 如下:
             public static final int num = 10;
             那么在经过准备的阶段,num的值会直接赋予实际值10;
      2.3 解析 解析符号引用转为直接引用
             符号引用:
                Class文件中它以CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info等类型的常量出现
                比如类A中引用了类B,在编译时,类A并不知晓类B的实际内存地址,因此使用符号引用来代替, 解析阶段就是将符号引用替换成类B在内存中的实际地址(直接引用)
             直接引用:
                如果有了直接引用,那么该引用的类必定已加载到内存(这边有个疑问?该引用的类是否已经执行了初始化阶段了? ::: 个人认为此时的引用类应该经过了加载/连接阶段了,但未完成初始化阶段)

                内存地址概念:
                  直接指向目标内存地址, 指向方法区的内存地址 一次定位 快速 但是在发生GC时,复制耗时,因为需要将所有存活的旧的引用地址调整为复制后的新地址(涉及年轻代的复制算法)
                  句柄 : 直接引用保存的只是句柄的地址, 句柄中保存的才是真正指向方法区的地址 , 也就是说使用该引用需要进行二次定位, 一次是定位到该引用的句柄,第二次是从句柄映射到方法区的实际内存地址
                         优点 : GC时,只需要修改句柄中的地址即可,其他存活的引用无需修改;

  3.初始化:
       此阶段为静态变量赋予真正的值, final修饰的静态常量无需再次赋予,因为在准备阶段已经赋值了
       所有的类/接口 必须在首次主动使用才初始化

  4.使用
  5.卸载

  java对类的使用分为:
        主动使用:
            1.new关键字
            2.反射调用  有个特例, 如果使用的是Class.forName("全限定类名",false,classloader) 那么是不会进行初始化的!;
            3.访问类的静态变量(非静态常量) , 对类的静态变量赋值 , 调用类的静态方法(即使是final修饰的静态方法也会)
            4.初始化一个类的子类
            5.main方法,被JVM标志为启动类的类
            6.methodHandle了解下即可!

            getstatic       获取静态变量指令
            putstatic       设置静态变量指令
            invokestatic    执行静态方法指定
            ldc    : 将int , float , string类型常量值从常量池推送到栈顶
            bipush : 将单字节(-128-127)的常量值推送至栈顶

        被动使用:
            除了主动使用之外的被称为被动时用, 被动使用不会导致类的初始化!

        -XX:+TraceClassLoading : 用于打印出被加载类的信息

        JVM参数设置方式:
            1. -XX:+<option> 开启option参数, 如-XX:+TraceClassLoading 有些参数是默认关闭的,可以使用此方式开启
            2. -XX:-<option> 关闭option参数  有些参数是默认开启的,可以只用此方式关闭
            3.-XX:<option>=<value>  设置option参数值为value, 如 -XX:xms=200m







