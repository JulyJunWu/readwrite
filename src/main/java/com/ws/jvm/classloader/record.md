
不规范笔记



  类型的加载->连接->初始化 都是在程序运行期间完成的.
  连接阶段 : 验证 准备 解析

  符号引用转为直接引用

  JAVA虚拟机结束生命周期:
    1.程序正常结束;
    2.调用System.exit()
    3.程序抛出异常
    4.操作系统发生故障,如:结束进程(kill)

  1.加载:
      查找并加载二进制字节码数据; 就是将class文件加载进JVM,将其放在运行时数据区的方法区,并在堆中创建一个class对象,用来封装类在的方法区的数据结构
      注意: JVM规范并未规定class对象放在哪里

      查找加载的范围很广, 并不局限于从本地加载文件, 如从数据库加载二进制字节流数据直接在内存中生成类,又或者通过URL访问加载,文件载体常见有.zip .jar等等


  2.连接:又分为三个阶段
      2.1 验证  主要是验证字节码的一些规范,是否安全,比如验证魔数,主版本和次版本 ; 是否符合,比如final类是否有子类等等
      2.2 准备  为静态变量分配内存,并将其初始化默认值 , 如 int默认0 , String(引用类)默认null,boolean默认false ; 准备阶段是赋予默认值,并非实际分配的值,实际的值在初始化阶段赋予真正的值;
             注意: 如果是final修饰的静态常量,那么是直接赋予真正的值, 如下:
             public static final int num = 10;
             那么在经过准备的阶段,num的值会直接赋予实际值10;
      2.3 解析 解析符号引用转为直接引用
             符号引用:
                Class文件中它以CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info等类型的常量出现
                比如类A中引用了类B,在编译时,类A并不知晓类B的实际内存地址,因此使用符号引用来代替, 解析阶段就是将符号引用替换成类B在内存中的实际地址(直接引用)
             直接引用:
                如果有了直接引用,那么该引用的类必定已加载到内存(这边有个疑问?该引用的类是否已经执行了初始化阶段了? ::: 个人认为此时的引用类应该经过了加载/连接阶段了,但未完成初始化阶段)

             内存地址概念:
                直接指向目标内存地址, 指向方法区的内存地址 一次定位 快速 但是在发生GC时,复制耗时,因为需要将所有存活的旧的引用地址调整为复制后的新地址(涉及年轻代的复制算法)
                句柄 : 直接引用保存的只是句柄的地址, 句柄中保存的才是真正指向方法区的地址 , 也就是说使用该引用需要进行二次定位, 一次是定位到该引用的句柄,第二次是从句柄映射到方法区的实际内存地址
                优点 : GC时,只需要修改句柄中的地址即可,其他存活的引用无需修改;

  3.初始化:
       此阶段为静态变量赋予真正的值, final修饰的静态常量无需再次赋予,因为在准备阶段已经赋值了
       所有的类/接口 必须在首次主动使用才初始化

  4.使用
  5.卸载

  java对类的使用分为:
        主动使用:
            1.new关键字
            2.反射调用  有个特例, 如果使用的是Class.forName("全限定类名",false,classloader) 那么是不会进行初始化的!;
            3.访问类的静态变量(非静态常量) , 对类的静态变量赋值 , 调用类的静态方法(即使是final修饰的静态方法也会)
            4.初始化一个类的子类
            5.main方法,被JVM标志为启动类的类
            6.methodHandle了解下即可!

            getstatic       获取静态变量指令
            putstatic       设置静态变量指令
            invokestatic    执行静态方法指定
            ldc    : 将int , float , string类型常量值从常量池推送到栈顶
            bipush : 将单字节(-128-127)的常量值推送至栈顶

        被动使用:
            除了主动使用之外的被称为被动时用, 被动使用不会导致类的初始化!

        -XX:+TraceClassLoading : 用于打印出被加载类的信息

        JVM参数设置方式:
            1. -XX:+<option> 开启option参数, 如-XX:+TraceClassLoading 有些参数是默认关闭的,可以使用此方式开启
            2. -XX:-<option> 关闭option参数  有些参数是默认开启的,可以只用此方式关闭
            3. -XX:<option>=<value>  设置option参数值为value, 如 -XX:xms=200m


  常量池:
    ICONST_m1 ~ ICONST_5  将-1 ~ 5 的数字压入栈 详情查看 com.sun.org.apache.bcel.internal.generic.ICONST
    BIPUSH -> 将单字节(-128-127)的常量值推送至栈顶com.sun.org.apache.bcel.internal.generic.BIPUSH
   
  数组不是对类的主动使用->因此不会导类初始化
  数组的实例是由JVM在运行期间生成的
  
  anewarray : 创建一个引用类型的数组(类,接口,数组),并将其引用值压入栈顶  L[  L[[
  newarray  : 创建一个原始类型数组(如byte,short,char,int等) , 并将其引用值压入栈顶 I[
  
  接口中的变量 ->默认 public static final 修饰 不能够有代码块
  
  类的实例化:
    1.对类实例分配内存
    2.对实例变量分配默认初始值
    3.对实例变量分配实际值
    java编译器会为每一个类的构造方法生成一个init方法(实例初始化方法)
    对类变量有一个cliinit方法(类变量初始化方法)
    
    
   类的加载最终产品是位于内存中的class对象
   class对象封装了类在方法区的数据结构,并提供了访问方法区内数据结构的接口
   
   类加载器:
     1.JDK自带加载器
       1.1 根加载器(启动加载器) Bootstrap         -> 加载系统属性sun.boot.class.path中的包或目录下的包,如rt.jar
       1.2 扩展加载器 Extension                  -> 加载jre/lib/ext包下 , 具体可看System.getProperty("java.ext.dirs")
       1.3 系统加载器(应用加载器) System (App)     ->  加载java.class.path属性值/环境变量classpath 下的
     2.用户自定义加载器
        2.1 必须是java.lang.ClassLoader的子类
        2.可以自定义加载的方式,只要加载进内存的是byte数组即可
        
        
   类的加载并不一定要等到类的首次主动使用才进行加载;
   JVM允许类加载预料某个类将要使用时可提前进行加载(未初始化),当加载.class文件有错误时,类加载器不会报错,而是当该类主动使用是跑出错误;
   如果该类一直未被主动使用,那么就不会抛出错误(linkageError错误) , 详情demo -> TestOne.java
   
   匿名类不能拥有构造函数,但是可以有普通代码块
   
   TODO -> P10
    
  
    




