
不规范笔记



  类型的加载->连接->初始化 都是在程序运行期间完成的.
  连接阶段 : 验证 准备 解析

  符号引用转为直接引用

  JAVA虚拟机结束生命周期:
    1.程序正常结束;
    2.调用System.exit()
    3.程序抛出异常
    4.操作系统发生故障,如:结束进程(kill)

  1.加载:
      查找并加载二进制字节码数据; 就是将class文件加载进JVM,将其放在运行时数据区的方法区,并在堆中创建一个class对象,用来封装类在的方法区的数据结构
      注意: JVM规范并未规定class对象放在哪里
      查找加载的范围很广, 并不局限于从本地加载文件, 如从数据库加载二进制字节流数据直接在内存中生成类,又或者通过URL访问加载,文件载体常见有.zip .jar等等


  2.连接:又分为三个阶段
      2.1 验证  主要是验证字节码的一些规范,是否安全,比如验证魔数,主版本和次版本 ; 是否符合,比如final类是否有子类等等
      2.2 准备  为静态变量分配内存,并将其初始化默认值 , 如 int默认0 , String(引用类)默认null,boolean默认false ; 准备阶段是赋予默认值,并非实际分配的值,实际的值在初始化阶段赋予真正的值;
             注意: 如果是final修饰的静态常量,那么是直接赋予真正的值, 如下:
             public static final int num = 10;
             那么在经过准备的阶段,num的值会直接赋予实际值10;
      2.3 解析 解析符号引用转为直接引用
             符号引用:
                Class文件中它以CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info等类型的常量出现
                比如类A中引用了类B,在编译时,类A并不知晓类B的实际内存地址,因此使用符号引用来代替, 解析阶段就是将符号引用替换成类B在内存中的实际地址(直接引用)
             直接引用:
                如果有了直接引用,那么该引用的类必定已加载到内存(这边有个疑问?该引用的类是否已经执行了初始化阶段了? ::: 个人认为此时的引用类应该经过了加载/连接阶段了,但未完成初始化阶段)
             内存地址概念:
                直接指向目标内存地址, 指向方法区的内存地址 一次定位 快速 但是在发生GC时,复制耗时,因为需要将所有存活的旧的引用地址调整为复制后的新地址(涉及年轻代的复制算法)
                句柄 : 直接引用保存的只是句柄的地址, 句柄中保存的才是真正指向方法区的地址 , 也就是说使用该引用需要进行二次定位, 一次是定位到该引用的句柄,第二次是从句柄映射到方法区的实际内存地址
                优点 : GC时,只需要修改句柄中的地址即可,其他存活的引用无需修改;

  3.初始化:
       此阶段为静态变量赋予真正的值, final修饰的静态常量无需再次赋予,因为在准备阶段已经赋值了
       所有的类/接口 必须在首次主动使用才初始化

  4.使用
  5.卸载

  java对类的使用分为:
        主动使用:
            1.new关键字
            2.反射调用  有个特例, 如果使用的是Class.forName("全限定类名",false,classloader) 那么是不会进行初始化的!;
            3.访问类的静态变量(非静态常量) , 对类的静态变量赋值 , 调用类的静态方法(即使是final修饰的静态方法也会)
            4.初始化一个类的子类
            5.main方法,被JVM标志为启动类的类
            6.methodHandle了解下即可!
            getstatic       获取静态变量指令
            putstatic       设置静态变量指令
            invokestatic    执行静态方法指定
            ldc    : 将int , float , string类型常量值从常量池推送到栈顶
            bipush : 将单字节(-128-127)的常量值推送至栈顶
        被动使用:
            除了主动使用之外的被称为被动时用, 被动使用不会导致类的初始化!
        -XX:+TraceClassLoading : 用于打印出被加载类的信息
        JVM参数设置方式:
            1. -XX:+<option> 开启option参数, 如-XX:+TraceClassLoading 有些参数是默认关闭的,可以使用此方式开启
            2. -XX:-<option> 关闭option参数  有些参数是默认开启的,可以只用此方式关闭
            3. -XX:<option>=<value>  设置option参数值为value, 如 -XX:xms=200m


  常量池:
    ICONST_m1 ~ ICONST_5  将-1 ~ 5 的数字压入栈 详情查看 com.sun.org.apache.bcel.internal.generic.ICONST
    BIPUSH -> 将单字节(-128-127)的常量值推送至栈顶com.sun.org.apache.bcel.internal.generic.BIPUSH
   
  数组不是对类的主动使用->因此不会导类初始化
  数组的实例是由JVM在运行期间生成的
  
  anewarray : 创建一个引用类型的数组(类,接口,数组),并将其引用值压入栈顶  L[  L[[
  newarray  : 创建一个原始类型数组(如byte,short,char,int等) , 并将其引用值压入栈顶 I[
  
  接口中的变量 ->默认 public static final 修饰 不能够有代码块
  
  类的实例化:
    1.对类实例分配内存
    2.对实例变量分配默认初始值
    3.对实例变量分配实际值
    java编译器会为每一个类的构造方法生成一个init方法(实例初始化方法)
    对类变量(静态变量)有一个cliinit方法(类变量初始化方法)
    
    
   类的加载最终产品是位于内存中的class对象
   class对象封装了类在方法区的数据结构,并提供了访问方法区内数据结构的接口
   
   类加载器:
     1.JDK自带加载器
       1.1 根加载器(启动加载器) Bootstrap         -> 加载系统属性sun.boot.class.path中的包或目录下的包,如rt.jar
       1.2 扩展加载器 Extension                  -> 加载jre/lib/ext包下 , 具体可看System.getProperty("java.ext.dirs")
       1.3 系统加载器(应用加载器) System (App)     ->  加载java.class.path属性值/环境变量classpath 下的
     2.用户自定义加载器
        2.1 必须是java.lang.ClassLoader的子类
        2.可以自定义加载的方式,只要加载进内存的是byte数组即可
   
   成功加载某个类的类加载器称为这个类的定义类加载器;
   所有能成功返回Class对象的类加载器称为初始类加载器; 例如 Test类被扩展类加载器成功加载, 那么Extension称为定义类加载器,Extension和系统加载器称为初始类加载器;
   ClassLoader的loadClass()方法并不会导致类进行初始化(不是主动使用); 详情 -> Test8.java
        
   类的加载并不一定要等到类的首次主动使用才进行加载;
   JVM允许类加载预料某个类将要使用时可提前进行加载(未初始化),当加载.class文件有错误时,类加载器不会报错,而是当该类主动使用是跑出错误;
   如果该类一直未被主动使用,那么就不会抛出错误(linkageError错误) , 详情demo -> TestOne.java
   
   匿名类不能拥有构造函数,但是可以有普通代码块;
   
   数组类型并不是由类加载器加载的,而是JVM在运行期间自动创建的,原生类型的数组是没有类加载器的;如下所示:
    String [] str = new String[5]; str.getClass().getClassLoader() -> 得到null(根类加载器) , 通过这样的方式得到的类加载器是与数组元素一致的类加载器
    int [] i = new int[5]; ; i.getClass().getClassLoader() -> null ,这个属于基本类型数组,此时的null是真的没有类加载器!
    
   
   defineClass create a class instance(注意是Class对象)
   loadClass 执行顺序:
     1.查找该类是否已将加载进内存了 findLoadedCLas();
     2.委托父类加载器去尝试加载 
     3.父类加载器若无法加载,则使用自己的findClass()去查找并加载;
    一般而言,自定义类加载器,主要是重写findClass方法(tomcat打破了双亲)
    
   ctrl + w 快捷键 
   
  每个类加载器都有自己的命名空间 , 命名空间由该加载器及所有父加载器所加载的类组成.
  在同一个命名空间内不会出现两个完全相同的类(类的全限定名) , 也就是说一个类只会被**当前**加载器加载一次;
  同一个类可以被不同命名空间的类加载器加载
  
  -XX:+TraceClassUnloading : 追踪class卸载的JVM参数
  可以通过JDK自带根据jvisualvm 查看已卸载的类的数量

   1.子加载器能够访问父加载器加载的类;
   2.父加载器无法访问子加载器所加载的类;
   
   
   双亲委托模型的好处:
    1.可以确保JAVA核心库的类型安全;
        所有JAVA应用都至少引用Object对象,如果每个JAVA应用都使用自身的类加载器,那么可能在应用中存在多个版本的Object类;
        由于命名空间的不同,每个Object类之间互相不可见,容易造成各种异常/错误;
        双亲委托机制保证了核心类库由启动类加载器统一加载,确保应用所使用的核心类库版本都是一致的,相互兼容;
    2.可以确保JAVA核心类库不会被自定义类加载器覆盖;
    3.不同的类加载器的命名空间是不相同的(比如自定义的类加载器多个实例化,同时用自身加载器加载相同的类,这些类虽然看上去一样,但是他们的Class对象地址完全不一样);
      这种隔离技术许多框架都应用;
      
   扩展类加载器(Extension)是不会加载单独*.class文件,只会加载*.jar包中的.class文件;
   
   在运行期间,一个JAVA类是由该类的完全限定名和该类的定义类加载器决定的(谁成功加载该类就是该类的定义类加载器);
   
   问题:类加载器也是一个JAVA类,那么谁去加载? 先有鸡还是先有蛋问题!
    Bootstrap , 启动类加载器不是JAVA类(C++),而其他的类加载器都是JAVA类;
    当JVM启动时,一块特殊的机器码会执行,它会加载扩展类加载器和系统类加载器,它就是启动类加载器;
    启动类加载器是一个特定于平台的机器指令,它负责启动整个加载过程;
    
  
   加载类加载器的步骤: java.lang.ClassLoader.getSystemClassLoader入口 -> sun.misc.Launcher
        1.加载扩展类加载器(同时设置所需加载.class的文件)
        2.加载应用类加载器,并将扩展类加载器设为应用类加载器的双亲(设置加载的目录或.class);
        3.将应用类加载器设置为线程上下文类加载器
        4.将应用类加载设置为ClassLoader类中的静态变量scl(该变量就是系统类加载器)
        4.读取系统属性java.system.class.loader,
            不存在该属性,则,直接返回;
            如果存在则通过带有一个参数的构造器反射创建(必须拥有一个参数为ClassLoader的构造器),
            将应用类加载设置为双亲;然后设置线程上下文类加载器为当前自定义的类加载器;
            最后将scl设置为用户自定义的类加载器;
    
   线程上下文类加载器: 改变了双亲委托模型
   SPI : Service Provider Interface
   ServiceLoader了解下,
   
   理解ServiceLoader.load(Driver.class)加载mysql的jdbc驱动之后,想想springBoot的自定义starter , 感觉很像!
   以前我们使用mysql的jdbc,需要Class.forName("com.jdbc.mysql.Driver)加载,
   现在根本不需要,因为DriverManager.loadInitialDrivers()已经帮我们自动加载(线程上下文类加载器)了,还有一种方式就是手动设置系统变量
   System.setProperty("jdbc.drivers","com.mysql.jdbc.Driver"); 多个驱动器则用:分割,这样DriverManager会去读取该变量去分割然后逐个加载驱动;
   
   类的init()方法其实就是执行普通代码块;
   
   lineNumberTable  行号 ,字节码对应代码中的位置
   localVariableTable   局部变量表 slot
   exceptionTable 异常表
   编译器自动生成any异常,处理其他异常处理不了的异常;
   有多少个个catch块,就会生成多少个finally的字节码指令;
   catch捕捉异常和方法抛出的异常不是在同一个地方,一个是在Code里面,另外一个是在与code同级的exceptions中;
   
   **栈帧**: stack frame 先进后出 , 后进先出
        栈帧是一种用于帮助虚拟机执行方法调用与方法执行的数据结构;
        栈帧本身是一种数据结构,封装了方法的局部变量表,动态链接信息,方法的返回地址以及操作数栈等信息;
        long 64位占用2个slot
        slot可以复用
        有些符号引用在类加载阶段或是第一次使用时就会转换为直接引用,这种转换叫做静态解析;另外一些符号则是在每次运行期转化为直接引用,这种转换叫做动态链接(多态)
   1.invokeinterface : 调用接口中的方法,实际上是在运行期间决定,决定到底调用哪个实现该接口的特定方法(接口中的default方法)
   2.invokestatic : 调用静态方法;
   3.invokespecial : 调用自己私有的方法,构造方法(<init>)以及父类的方法
   4.invokevirtual : 调用虚方法,运行期间动态查找(个人理解:比如实现某个类或接口,当需要调用此方法时,去寻找到底改调哪个方法,多态);
   5.invokedynamic : 动态调用方法;
   
   静态解析的四种情况:
    1.静态方法
    2.构造方法
    3.私有方法
    4.父类方法
    以上四种称为非虚方法(不能被重写)
    
   静态分派  动态分派
   
   现代JVM在执行java代码的时候,通过都会将解释执行与编译执行二者结合起来进行;
   解释执行: 就是通过解释器来读取字节码,遇到相应的指令就去执行该指令;
   编译执行: 就是通过即时编译器(Just In Time , JIT) 将字节码转换为本地机器码来执行;现代JVM会根据二代吗热点来生成相应的本地机器码;
   
   基于栈的指令集与基于寄存器的指令集之间的关系:
      JVM执行指令时所采取的的方式是基于栈的指令集;
      基于栈的指令集主要的操作有入栈和出栈两种;
      基于栈的指令集优势: 可以在不同平台之间互相移植 , 而基于寄存器的指令集是与硬件架构紧密关联,无法做到可移植;
      ------------缺点: 指令数量通常要比基于寄存器的指令集数量要多;意思是同样的操作,基于栈的指令集需要执行的指令多;
                        基于栈的指令集是在内存中完成操作的,而基于寄存器是在高速缓存中完成的,速度要快很多;
    
   动态代码: ProxyGenerator.generateProxyClass 动态生成字节码的字节数组
    
   系统属性 sun.misc.ProxyGenerator.saveGeneratedFiles设置是否生成动态代理生成的.class文件 , 生成的字节码文件在当前项目下com.sun.proxy.$ProxyN.class
    
    
   HashMap 比较两个值是否为同一个 : 比较hashCode && (比较两个对象的地址是否相同 || equals是否相同)
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
   
   P50
   8/17 : 任务: 把JVM内容复习一遍
     
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
  
    




