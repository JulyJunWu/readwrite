字节码笔记:
   简略信息 javap -c com.ws.jvm.bytecode.Test1
   详细信息  javap -verbose com.ws.jvm.bytecode.Test1
   
**魔数**: 所有的.class字节码文件的前4个字节都是魔数,魔数为固定值 0xCAFFBABE (1-4字节)
**版本号**: 从5-8字节 代表版本号
     5-6 字节: 次版本号, 一般都是00 00
     7-8 字节: 主版本号, 代表着JDK的版本 比如 00 34(16进制) 转换成10进制为52,就是对应jdk1.8 , jdk1.7就是51 , 依次往前推;
   
**常量池**(constant pool): 紧接着主版本号的就是常量池
     一个JAVA类中定义的很多信息都是由常量池来维护和描述的,可以将常量池看成class文件的资源仓库,比如java类中定义的方法和变量信息,都是存储在常量池中; 
     常量池主要存储量大常量:字面量和符号引用. 字面量如文本字符串,java中声明为final的常量值等,而符号引用如类和接口的全限定类名,字段的名称和描述,方法的名称和描述;
**常量池总体结构**: JAVA类所对应的常量池主要由常量池数量与常量池数组这两部分构成;
     常量池数量紧跟在主版本号后面,占2个字节(从第9-10字节); 常量池数组则紧跟常量池数量后面(也就是从第11个字节开始);
     常量池数组与一般的数组不同的是,常量池数组中不同的元素的类型,结构都是不一样的,长度当然也不一样;但是每一个元素的第一个数据都是一个**u1类型**,该字节是个标志位,占一个字节.JVM在解析常量池时,
     会根据这个u1类型来获取元素的具体类型;
     例如com.ws.jvm.bytecode.Test1查看其他字节码,可知 00 18 (16进制)转成10进制为24 ,就是代表常量池数组的数量;
     但是有一个要注意的,常量池数组是从1开始的,0暂时不使用,也就说真正的常量池数组长度 = 常量池数量 - 1 = 23 个,从java -verbose com.ws.jvm.bytecode.Test1能得出常量池数组长度为23;
     不使用0目的是满足某些常量池索引值的数据在特定情况下需要表达 **不引用任何一个常量池** 的含义;根本原因在于,索引0也是一个常量(保留常量,感觉有点类似JAVA中的保留关键字),只不过它不位于常量池中,这个常量就对应null值;所以,常量池的索引从1开始,而非0开始;
     在JVM规范中,每个变量/字段都有描述信息,描述信息主要的作用是描述字段的的数据类型,方法的参数列表(包括数量,类型,顺序)与返回值.
     根据描述符规则,基本数据类型和代表无返回值的void类型都用大写字符来表示,对象类型则使用字符L加对象的全限定名称来表示.为了压缩字节码文件的体积(给机器看得),对于基本数据类型,JVM都只使用一个大写的字母来表示,如下所示:
       B -> byte
       C -> char
       D -> double
       F -> float
       J -> long 
       I -> int
       S -> short
       Z -> boolean
       V -> void
       L -> 对象类型 , 如Ljava/lang/String;
    对于数据类型来说,每一个维度使用一个[来表示,如int [] 表示为 [I , String [] [] 表示为 [[Ljava/lang/String
    **描述符是给机器看的**
    用描述符描述方法,按照参数列表的顺序,后返回值的顺序来描述.参数列表按照参数的严格顺序放在一组()之内,如方法 String getName(int i , String str) 用描述符来表示为 (I,Ljava/lang/String)Ljava/lang/String
     
**class字节码中有两种数据类型**:
    1.字节数据直接量:  这是基本的数据类型.共细分为u1,u2,u4,u8四种,分表代表连续的1个字节,2个字节,4个字节,8个字节组成的整体数据;
    2.表(数组):表示由多个基本数据或其他表,按照既定顺序组成的大的数据集合.表示有结构的,它的机构体现在,组成表的成分所在的位置和顺序是严格定义好的.

**Access_Flag访问标志**
    访问标志信息包括该Class文件时类还是接口,是否定义成public,是否是abstract;如果是类,是否被声明成final;
    访问修饰符16进制值表示如下:
        ACC_PUBLIC      0x0001 
        ACC_FINAL       0x0010
        ACC_SUPER       0x0020
        ACC_INTERFACE   0x0200
        ACC_ABSTRACT    0x0400
        ACC_SYNTHETIC   0x1000
        ACC_ANNOTATION  0x2000
        ACC_ENUM        0x4000
     
**字段表集合**    
    字段表用于描述类和接口中声明的变量.这里的字段包含了类级别变量以及实例变量,但是不包括方法内部声明的局部变量;
    先计算出fields的数量,2个字节 , 然后每个field都包含了字段表结构(请看字段表结构图.png)
    
Code结构:
    attribute_length 表示attribute所包含的字节数,不包含attribute_name_index和attribute_length字段
    max_stack : 表示这个方法运行的任何时刻所能达到的操作数栈的最大深度
    max_Locals: 表示方法执行期间创建的局部变量的数目,包含用来表示传入参数的局部变量(在非静态方法中this也是一个参数)
    code_length: 表示该方法所包含的字节码的字节数以及具体的指令码 , 具体字节码是该方法被调用后,虚拟机所执行的字节码
    exception_table : 存放处理异常的信息
      每个exception_table由start_pc,end_pc,handler_pc,catch_type组成
    


   P46

     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
        
     
     
     
     
   
    
    